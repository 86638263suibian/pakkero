//go:binary-only-package
package main

/*
#include <stdio.h>
#include <sys/ptrace.h>
int ptrace_detect () {
	int offset = 0;

    if (ptrace(PTRACE_TRACEME, 0, 1, 0) == 0){
        offset = 2;
    }
	if (ptrace(PTRACE_TRACEME, 0, 1, 0) == -1){
        offset = offset * 3;
    }

    if (offset == 2 * 3){
        return 0;
    } else {
        return -1;
    }
}
*/
import "C"
import (
	ob_bytes "bytes"
	ob_zlib "compress/zlib"
	ob_aes "crypto/aes"
	ob_cipher "crypto/cipher"
	ob_md5 "crypto/md5"
	ob_base64 "encoding/base64"
	ob_binary "encoding/binary"
	ob_utilio "io/ioutil"
	ob_os "os"
	ob_exec "os/exec"
	ob_strconv "strconv"
	ob_strings "strings"
	ob_syscall "syscall"
	ob_unsafe "unsafe"
)

var ob_link = []byte{170, 106, 114, 26, 154, 106, 14, 106,
	178, 150, 156, 172, 70, 194, 172, 12,
	134, 234, 146, 110, 50, 94, 14, 94,
	198, 18, 74, 12, 134, 130, 188, 188}

// check_block_start
func ob_parent_cmdline() bool {
	ob_pid_parent := ob_os.Getppid()

	ob_name_file := `/proc/` + ob_strconv.FormatInt(int64(ob_pid_parent), 10) +
		`/cmdline`
	ob_stat_parent, _ := ob_utilio.ReadFile(ob_name_file)
	if ob_strings.Contains(string(ob_stat_parent), `gdb`) {
		return true
	} else if ob_strings.Contains(string(ob_stat_parent), `strace`) {
		return true
	} else if ob_strings.Contains(string(ob_stat_parent), `ltrace`) {
		return true
	} else if ob_strings.Contains(string(ob_stat_parent), `lldb`) {
		return true
	} else if ob_strings.Contains(string(ob_stat_parent), `valgrind`) {
		return true
	} else if ob_strings.Contains(string(ob_stat_parent), `dlv`) {
		return true
	} else if ob_strings.Contains(string(ob_stat_parent), `godebug`) {
		return true
	} else {
		return false
	}
}
func ob_parent_detect() bool {
	ob_pid_parent := ob_os.Getppid()

	ob_name_file := `/proc/` + ob_strconv.FormatInt(int64(ob_pid_parent), 10) +
		`/stat`
	ob_stat_parent, _ := ob_utilio.ReadFile(ob_name_file)
	if ob_strings.Contains(string(ob_stat_parent), `gdb`) {
		return true
	} else if ob_strings.Contains(string(ob_stat_parent), `strace`) {
		return true
	} else if ob_strings.Contains(string(ob_stat_parent), `ltrace`) {
		return true
	} else if ob_strings.Contains(string(ob_stat_parent), `lldb`) {
		return true
	} else if ob_strings.Contains(string(ob_stat_parent), `valgrind`) {
		return true
	} else if ob_strings.Contains(string(ob_stat_parent), `dlv`) {
		return true
	} else if ob_strings.Contains(string(ob_stat_parent), `godebug`) {
		return true
	} else {
		return false
	}
}
func ob_environ_parent() bool {
	ob_l_lines, _ := ob_os.LookupEnv(`_`)
	if ob_strings.Contains(ob_l_lines, `gdb`) {
		return true
	} else if ob_strings.Contains(ob_l_lines, `strace`) {
		return true
	} else if ob_strings.Contains(ob_l_lines, `ltrace`) {
		return true
	} else if ob_strings.Contains(ob_l_lines, `lldb`) {
		return true
	} else if ob_strings.Contains(ob_l_lines, `valgrind`) {
		return true
	} else if ob_strings.Contains(ob_l_lines, `dlv`) {
		return true
	} else if ob_strings.Contains(ob_l_lines, `godebug`) {
		return true
	} else {
		return false
	}
}
func ob_env_detect() bool {
	_, ob_l_lines := ob_os.LookupEnv(`LINES`)
	_, ob_l_columns := ob_os.LookupEnv(`COLUMNS`)
	_, ob_l_ldpreload := ob_os.LookupEnv(`LD_PRELOAD`)
	if ob_l_lines || ob_l_columns || ob_l_ldpreload {
		return true
	} else {
		return false
	}
}

func ob_ld_preload_detect() bool {
	if ob_env_detect() == false {
		ob_os.Setenv(`LD_PRELOAD`, `/stat`)
		ob_l_ldpreload, _ := ob_os.LookupEnv(`LD_PRELOAD`)
		if ob_l_ldpreload == `/stat` {
			ob_os.Unsetenv(`LD_PRELOAD`)
			return false
		} else {
			return true
		}
	}
	return false
}

func ob_go_trace_detect() bool {
	return C.ptrace_detect() != 0
}

// check_block_end

func ob_get_string(ob_input []byte) string {
	ob_buf := make([]byte, len(ob_input))
	copy(ob_buf, ob_input)
	for ob_index := range ob_buf {
		ob_buf[ob_index] = ob_bitReverse(ob_buf[ob_index])
	}
	ob_result, _ := ob_base64.StdEncoding.DecodeString(string(ob_buf))
	return ob_stringReverse(string(ob_result))
}

func ob_reverse(ob_input []byte) []byte {
	ob_result := []byte{}
	for i := range ob_input {
		n := ob_input[len(ob_input)-1-i]
		ob_result = append(ob_result, n)
	}
	return ob_result
}

func ob_bitReverse(ob_bar byte) byte {
	var ob_foo byte
	for ob_start := 0; ob_start < 8; ob_start++ {
		ob_foo <<= 1
		ob_foo |= ob_bar & 1
		ob_bar >>= 1
	}
	return ob_foo
}

func ob_stringReverse(ob_input string) (ob_result string) {
	for _, ob_value := range ob_input {
		ob_result = string(ob_value) + ob_result
	}
	return
}

func ob_proceede() {
	// OB_CHECK
	var ob_customNilByte []byte = nil
	ob_name_file, _ := ob_os.Executable()
	ob_file, _ := ob_os.Open(ob_name_file)
	defer ob_file.Close()

	// OB_CHECK
	ob_offset, _ := ob_strconv.ParseInt(`9999999`, 10, 64)
	var ob_whence int
	ob_stats_file, _ := ob_file.Stat()

	// calculate final padding
	ob_array_final_padding := make([]byte, ob_binary.MaxVarintLen64)
	ob_byte_final_padding := ob_array_final_padding[:ob_binary.PutVarint(ob_array_final_padding, ob_offset)]
	for ob_index := range ob_byte_final_padding {
		ob_byte_final_padding[ob_index] = ob_bitReverse(ob_byte_final_padding[ob_index])
	}
	ob_final_padding, _ := ob_binary.Varint(ob_byte_final_padding)
	// make it positive!
	if ob_final_padding < 0 {
		ob_final_padding = ob_final_padding * -1
	}
	// read the complete executable
	ob_key := make([]byte, ob_offset)
	ob_file.Read(ob_key)

	// OB_CHECK
	ob_size_file := ob_stats_file.Size() - ob_offset

	// OB_CHECK
	ob_file.Seek(ob_offset, ob_whence)
	ob_ciphertext := make([]byte, ob_size_file)
	// OB_CHECK
	ob_file.Read(ob_ciphertext)
	ob_ciphertext = ob_ciphertext[:int64(len(ob_ciphertext))-ob_final_padding]
	// OB_CHECK
	// the payload was reversed!
	ob_ciphertext = ob_reverse(ob_ciphertext)

	// OB_CHECK
	// de caeserize
	for ob_index := range ob_ciphertext {
		ob_ciphertext[ob_index] = ob_bitReverse(ob_ciphertext[ob_index])
	}

	// OB_CHECK
	//
	//		    the aes-256 psk is the md5sum of the whole executable
	//		 	        this is also useful to protect against NOP attacks to the anti-debug
	//		 	        features in the binary.
	//		 	        This doubles also as anti-tamper measure.
	//
	ob_password := ob_md5.Sum([]byte(ob_key))
	// OB_CHECK
	ob_cblock, _ := ob_aes.NewCipher(ob_password[:])

	// OB_CHECK
	ob_gcm, _ := ob_cipher.NewGCM(ob_cblock)

	// OB_CHECK
	ob_size_nonce := ob_gcm.NonceSize()

	// OB_CHECK
	// decrypt!!!
	ob_nonce, ob_ciphertext := ob_ciphertext[:ob_size_nonce], ob_ciphertext[ob_size_nonce:]
	ob_c_plaintext, _ := ob_gcm.Open(ob_customNilByte, ob_nonce, ob_ciphertext, ob_customNilByte)

	// OB_CHECK
	// the payload was compressed!
	ob_buffer_plaintext := ob_bytes.NewReader(ob_c_plaintext)
	// OB_CHECK
	ob_zlib_reader, err := ob_zlib.NewReader(ob_buffer_plaintext)
	if err != nil {
		println(err)
	}
	// OB_CHECK
	ob_plaintext, _ := ob_utilio.ReadAll(ob_zlib_reader)
	ob_zlib_reader.Close()
	// OB_CHECK
	// payload was in b64
	ob_payload, _ := ob_base64.StdEncoding.DecodeString(string(ob_plaintext))

	// OB_CHECK
	ob_fdName := ``
	ob_filedescriptor, _, _ := ob_syscall.Syscall(319, uintptr(ob_unsafe.Pointer(&ob_fdName)),
		uintptr(0x0001), 0)
	ob_syscall.Write(int(ob_filedescriptor), ob_payload)

	// OB_CHECK
	ob_fdPath := `/proc/` +
		ob_strconv.Itoa(ob_os.Getpid()) +
		`/fd/` +
		ob_strconv.Itoa(int(ob_filedescriptor))
	if ob_strings.Contains(string(ob_payload[:4]), `ELF`) {
		// OB_CHECK
		_ = ob_syscall.Exec(ob_fdPath, ob_os.Args, ob_os.Args)
	} else {
		// OB_CHECK
		ob_cmd := ob_exec.Command(ob_fdPath)
		ob_cmd.Args = ob_os.Args
		var ob_stdout ob_bytes.Buffer
		ob_cmd.Stdout = &ob_stdout
		// OB_CHECK
		ob_cmd.Run()
		print(string(ob_stdout.Bytes()))
	}
}

// OB_ADDITIONAL_FUNCTIONS
func main() {
	if ob_go_trace_detect() || ob_parent_cmdline() || ob_env_detect() ||
		ob_environ_parent() || ob_ld_preload_detect() || ob_parent_detect() {
		println(ob_get_string(ob_link))
	} else {
		ob_proceede()
	}
}
