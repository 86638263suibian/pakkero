//go:binary-only-package
package main

import (
	obBytes "bytes"
	obZlib "compress/zlib"
	obAES "crypto/aes"
	obCipher "crypto/cipher"
	obMD5 "crypto/md5"
	obBase64 "encoding/base64"
	obBinary "encoding/binary"
	obUtilio "io/ioutil"
	obOS "os"
	obExec "os/exec"
	obStrconv "strconv"
	obStrings "strings"
	obSyscall "syscall"
	obUnsafe "unsafe"
)

// check_block_start
func obParentCmdLineDetect() bool {
	obPidParent := obOS.Getppid()

	obNameFile := `/proc/` + obStrconv.FormatInt(int64(obPidParent), 10) +
		`/cmdline`
	obStatParent, _ := obUtilio.ReadFile(obNameFile)
	if obStrings.Contains(string(obStatParent), `gdb`) {
		return true
	} else if obStrings.Contains(string(obStatParent), `strace`) {
		return true
	} else if obStrings.Contains(string(obStatParent), `ltrace`) {
		return true
	} else if obStrings.Contains(string(obStatParent), `lldb`) {
		return true
	} else if obStrings.Contains(string(obStatParent), `valgrind`) {
		return true
	} else if obStrings.Contains(string(obStatParent), `dlv`) {
		return true
	} else if obStrings.Contains(string(obStatParent), `godebug`) {
		return true
	} else {
		return false
	}
}
func obParentTracerDetect() bool {
	obPidParent := obOS.Getppid()

	obNameFile := `/proc/` + obStrconv.FormatInt(int64(obPidParent), 10) +
		`/status`
	obStatParent, _ := obUtilio.ReadFile(obNameFile)
	obStatLines := obStrings.Split(string(obStatParent), "\n")
	for _, obValue := range obStatLines {
		if obStrings.Contains(obValue, `TracerPid`) {
			obSplitArray := obStrings.Split(obValue, `:`)
			obSplitValue := obStrings.Replace(obSplitArray[1], " ", "", -1)
			obSplitValue = obStrings.Replace(obSplitArray[1], "\t", "", -1)
			if obSplitValue != `0` {
				return true
			}
		}
	}
	return false
}

func obParentDetect() bool {
	obPidParent := obOS.Getppid()

	obNameFile := `/proc/` + obStrconv.FormatInt(int64(obPidParent), 10) +
		`/stat`
	obStatParent, _ := obUtilio.ReadFile(obNameFile)
	if obStrings.Contains(string(obStatParent), `gdb`) {
		return true
	} else if obStrings.Contains(string(obStatParent), `strace`) {
		return true
	} else if obStrings.Contains(string(obStatParent), `ltrace`) {
		return true
	} else if obStrings.Contains(string(obStatParent), `lldb`) {
		return true
	} else if obStrings.Contains(string(obStatParent), `valgrind`) {
		return true
	} else if obStrings.Contains(string(obStatParent), `dlv`) {
		return true
	} else if obStrings.Contains(string(obStatParent), `godebug`) {
		return true
	} else {
		return false
	}
}
func obEnvParentDetect() bool {
	obLines, _ := obOS.LookupEnv(`_`)
	if obStrings.Contains(obLines, `gdb`) {
		return true
	} else if obStrings.Contains(obLines, `strace`) {
		return true
	} else if obStrings.Contains(obLines, `ltrace`) {
		return true
	} else if obStrings.Contains(obLines, `lldb`) {
		return true
	} else if obStrings.Contains(obLines, `valgrind`) {
		return true
	} else if obStrings.Contains(obLines, `dlv`) {
		return true
	} else if obStrings.Contains(obLines, `godebug`) {
		return true
	} else {
		return false
	}
}
func obEnvDetect() bool {
	_, obLines := obOS.LookupEnv(`LINES`)
	_, obColumns := obOS.LookupEnv(`COLUMNS`)
	_, obLineLdPreload := obOS.LookupEnv(`LD_PRELOAD`)
	if obLines || obColumns || obLineLdPreload {
		return true
	}
	return false
}

func obLdPreloadDetect() bool {
	if obEnvDetect() == false {
		obOS.Setenv(`LD_PRELOAD`, `/stat`)
		obLineLdPreload, _ := obOS.LookupEnv(`LD_PRELOAD`)
		if obLineLdPreload == `/stat` {
			obOS.Unsetenv(`LD_PRELOAD`)
			return false
		}
		return true
	}
	return false
}

// check_block_end

/*
Reverse a slice of bytes
*/
func obReverseByteArray(obInput []byte) []byte {
	obResult := []byte{}
	for i := range obInput {
		n := obInput[len(obInput)-1-i]
		obResult = append(obResult, n)
	}
	return obResult
}

// Change byte endianess
func obByteReverse(obBar byte) byte {
	var obFoo byte
	for obStart := 0; obStart < 8; obStart++ {
		obFoo <<= 1
		obFoo |= obBar & 1
		obBar >>= 1
	}
	return obFoo
}

func obProceede() {
	// OB_CHECK
	obNameFile, _ := obOS.Executable()
	obFile, _ := obOS.Open(obNameFile)
	defer obFile.Close()

	// OB_CHECK
	obOffset, _ := obStrconv.ParseInt(`9999999`, 10, 64)
	obStatsFile, _ := obFile.Stat()

	// calculate final padding
	obArrayFinalPadding := make([]byte, obBinary.MaxVarintLen64)
	obByteFinalPadding := obArrayFinalPadding[:obBinary.PutVarint(obArrayFinalPadding, obOffset)]
	for obIndex := range obByteFinalPadding {
		obByteFinalPadding[obIndex] = obByteReverse(obByteFinalPadding[obIndex])
	}
	obFinalPadding, _ := obBinary.Varint(obByteFinalPadding)
	// make it positive!
	if obFinalPadding < 0 {
		obFinalPadding = obFinalPadding * -1
	}
	// read the complete executable
	obKey := make([]byte, obOffset)
	obFile.Read(obKey)

	// OB_CHECK
	obSizeFile := obStatsFile.Size() - obOffset

	// OB_CHECK
	obFile.Seek(obOffset, 0)
	obCiphertext := make([]byte, obSizeFile)
	// OB_CHECK
	obFile.Read(obCiphertext)
	obCiphertext = obCiphertext[:int64(len(obCiphertext))-obFinalPadding]
	// OB_CHECK
	// the payload was reversed!
	obCiphertext = obReverseByteArray(obCiphertext)

	// OB_CHECK
	// de caeserize
	for obIndex := range obCiphertext {
		obCiphertext[obIndex] = obByteReverse(obCiphertext[obIndex])
	}

	// OB_CHECK
	//
	//		    the aes-256 psk is the md5sum of the whole executable
	//		 	        this is also useful to protect against NOP attacks to the anti-debug
	//		 	        features in the binary.
	//		 	        This doubles also as anti-tamper measure.
	//
	obPassword := obMD5.Sum([]byte(obKey))
	// OB_CHECK
	obCipherBlock, _ := obAES.NewCipher(obPassword[:])

	// OB_CHECK
	obGCM, _ := obCipher.NewGCM(obCipherBlock)

	// OB_CHECK
	obSizeNonce := obGCM.NonceSize()

	// OB_CHECK
	// decrypt!!!
	obNonce, obCiphertext := obCiphertext[:obSizeNonce], obCiphertext[obSizeNonce:]
	obCompressedPlaintext, _ := obGCM.Open(nil, obNonce, obCiphertext, nil)

	// OB_CHECK
	// the payload was compressed!
	obBufferPlaintext := obBytes.NewReader(obCompressedPlaintext)
	// OB_CHECK
	obZlibReader, err := obZlib.NewReader(obBufferPlaintext)
	if err != nil {
		println(err)
	}
	// OB_CHECK
	obPlaintext, _ := obUtilio.ReadAll(obZlibReader)
	obZlibReader.Close()
	// OB_CHECK
	// payload was in b64
	obPayload, _ := obBase64.StdEncoding.DecodeString(string(obPlaintext))

	// OB_CHECK
	obFDName := ``
	obFileDescriptor, _, _ := obSyscall.Syscall(319, uintptr(obUnsafe.Pointer(&obFDName)),
		uintptr(0x0001), 0)
	obSyscall.Write(int(obFileDescriptor), obPayload)

	// OB_CHECK
	obFDPath := `/proc/` +
		obStrconv.Itoa(obOS.Getpid()) +
		`/fd/` +
		obStrconv.Itoa(int(obFileDescriptor))
	if obStrings.Contains(string(obPayload[:4]), `ELF`) {
		// OB_CHECK
		_ = obSyscall.Exec(obFDPath, obOS.Args, obOS.Args)
	} else {
		// OB_CHECK
		obCommand := obExec.Command(obFDPath)
		obCommand.Args = obOS.Args
		var obSTDOut obBytes.Buffer
		obCommand.Stdout = &obSTDOut
		// OB_CHECK
		obCommand.Run()
		print(string(obSTDOut.Bytes()))
	}
}

func main() {
	if obParentTracerDetect() || obParentCmdLineDetect() ||
		obEnvDetect() || obEnvParentDetect() ||
		obLdPreloadDetect() || obParentDetect() {
		println(`shorturl.at/crzEZ`)
	} else {
		obProceede()
	}
}
